#include <stdio.h>
#include "RndGenerator.h"
#include <chrono>
#include <map>


using namespace std;

map<uint8_t, char> digits{ {0b0, '1'}, {0b1, '2'}, {0b10, '3'}, {0b11, '4'}, {0b100, '5'}, {0b101, '6'}, {0b110, '7'}, {0b111, '8'} };
map<uint8_t, char> chars{ {0b0, 'a'}, {0b1, 'b'}, {0b10, 'c'}, {0b11, 'd'}, {0b100, 'e'}, {0b101, 'f'}, {0b110, 'g'}, {0b111, 'q'},  {0b1000, 'k'}, {0b1001, 'u'}, {0b1010, 'r'}, {0b1011, 's'}, {0b1100, 'o'}, {0b1101, 'x'}, {0b1110, 'y'}, {0b1111, 'n'} };

map<char, uint8_t> r_digits{ {'1', 0b0}, {'2', 0b1}, {'3', 0b10}, {'4', 0b11}, {'5', 0b100}, {'6', 0b101}, {'7', 0b110}, {'8', 0b111} };
map<char, uint8_t> r_chars{ {'a', 0b0}, {'b', 0b1}, {'c', 0b10}, {'d', 0b11}, {'e', 0b100}, {'f', 0b101}, {'g', 0b110}, {'q', 0b111},  {'k', 0b1000}, {'u', 0b1001}, {'r', 0b1010}, {'s', 0b1011}, {'o', 0b1100}, {'x', 0b1101}, {'y', 0b1110}, {'n', 0b1111} };


uint32_t encaps_time(uint32_t token, uint32_t timestamp) {
	return token ^ timestamp;
};

void encode_bytes_to_char(uint32_t token, char* out) {
	uint8_t d1 = (token & 0xe0000000) >> 29;		//первые 3 бита;
	out[0] = digits[d1];
	uint8_t d2 = (token & 0x1c000000) >> 26;		//следующие 3 бита;
	out[1] = digits[d2];


	uint8_t c1 = (token & 0x3c00000) >> 22;			//следующие 4 бита на 1 букву
	out[2] = chars[c1];
	uint8_t c2 = (token & 0x3c0000) >> 18;			//вторая буква
	out[3] = chars[c2];
	uint8_t c3 = (token & 0x3c000) >> 14;			//третья буква
	out[4] = chars[c3];


	uint8_t d3 = (token & 0x3800) >> 11;			//еще 2 цифры
	out[5] = digits[d3];
	uint8_t d4 = (token & 0x700) >> 8;
	out[6] = digits[d4];


	uint8_t c4 = (token & 0xf0) >> 4;				//последние 2 буквы
	out[7] = chars[c4];
	uint8_t c5 = (token & 0xf);
	out[8] = chars[c5];

	out[9] = '\0';
	return;
};

void decode_chr_to_bytes(char* buf, uint32_t &token) {
	uint32_t temp;

	token = token | (r_digits[buf[0]] << 29);
	token = token | (r_digits[buf[1]] << 26);

	temp = (r_chars[buf[2]]);
	token = token | (r_chars[buf[2]] << 22);

	temp = (r_chars[buf[3]]);
	token = token | (r_chars[buf[3]] << 18);

	temp = (r_chars[buf[4]]);
	token = token | (r_chars[buf[4]] << 14);

	token = token | (r_digits[buf[5]] << 11);
	token = token | (r_digits[buf[6]] << 8);

	token = token | (r_chars[buf[7]] << 4);
	token = token | (r_chars[buf[8]]);
	return;
};


int main()
{
	const auto p1 = system_clock::now();		//КБО сохраняет информацию о времени входа пилота после сопоставления токена и сертификата с точностью до минут


	uint32_t time = duration_cast<seconds>(p1.time_since_epoch()).count();		//в беззнаковых 4 байтах можно сохранить информацию о количестве прошедших секунд до 2106 года
	printf("%u  <- Timestamp (sec)\n", time);


	entropy temp{ thisThreadId(), pid(), getCurTimeNSC() };
	const char *msg = (const char*)&temp;
	size_t len;
	int i;
	uint8_t result[16];

	len = sizeof(entropy);

	md5((uint8_t*)msg, len, result);

	for (i = 0; i < 16; i++)
		printf("%x ", result[i]);		//генерируем 16-байтовый хеш. Для токена нам нужно только первые 4 байта
	printf("  <- Generated bytes\n");

	uint32_t token = 0;			// 4 сгенерированных байта зенесем в uint32 для удобства работы с битовыми операциями

	for (int k = 0; k < 4; k++)
		token += result[3 - k] << (k * 8);		//копируем 4 первых байта из случайной последовательности в токен

	char push_code[10];

	uint32_t KBO_TOKEN = token;
	printf("\n%x  <- KBO TOKEN\n", KBO_TOKEN);		// АВИАКОМПАНИЯ -> КБО

	token = encaps_time(token, time);

	printf("\n%x  <- Encapsulated time PILOT TOKEN\n", token);

	encode_bytes_to_char(token, push_code);
	printf("\n%s  <- Encoded to digits and chars code\n", push_code);		// АВИАКОМПАНИЯ -> ПИЛОТ

	uint32_t temp_token = 0;
	decode_chr_to_bytes(push_code, temp_token);
	printf("\n%x <- Decoded PILOT TOKEN from dig-chr code\n", temp_token);		//ПИЛОТ -> КБО

	uint32_t t = encaps_time(temp_token, KBO_TOKEN);
	printf("\n%u <- Extracted timestamp from token\n", t);
}

/*

12 abb 12 ab

2 * 3 bits + 3 * 4 bits + 2 * 3 bits + 2 * 4 bits = 32 bits

*/
